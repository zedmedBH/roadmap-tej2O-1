<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic VEX Roadmap</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 { color: #333; margin-bottom: 10px; }

        /* Container for the canvas and the tooltip */
        #canvas-container {
            position: relative;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border-radius: 12px;
            overflow: hidden;
            background: white;
        }

        canvas {
            display: block;
            background: radial-gradient(circle, #ffffff 0%, #f0f0f0 100%);
            cursor: crosshair;
        }

        /* The Hover Tooltip Card */
        #tooltip {
            position: absolute;
            display: none; /* Hidden by default */
            width: 220px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            border-left: 5px solid #333;
            pointer-events: none; /* Allows mouse to pass through to canvas */
            z-index: 10;
            transition: opacity 0.2s;
        }

        #tooltip h3 { margin: 0 0 5px 0; font-size: 16px; color: #222; }
        #tooltip p { margin: 0; font-size: 13px; color: #555; }
        #tooltip .meta { font-size: 11px; color: #888; margin-top: 5px; font-weight: bold; }
        #tooltip .hint { margin-top: 8px; font-size: 11px; color: #007bff; }

    </style>
</head>
<body>

    <h1>VEX Stack Build Roadmap</h1>
    <p>Hover for details. Click to open lesson.</p>

    <div id="canvas-container">
        <canvas id="roadmapCanvas" width="1000" height="400"></canvas>
        <div id="tooltip"></div>
    </div>

<script>
    // ==========================================
    // 1. CONFIGURATION (EDIT THIS DATA!)
    // ==========================================
    // Add as many checkpoints as you want here. The road will stretch to fit.
    const checkpoints = [
        { 
            title: "1. Holonomic Drivetrain", 
            pages: "Pages 4-22", 
            qc: "Check X-pattern on wheels",
            color: "#00C853", // Green
            url: "https://www.youtube.com/user/vexrobotics" 
        },
        { 
            title: "2. Towers & Brain", 
            pages: "Pages 23-31", 
            qc: "Ensure towers parallel",
            color: "#FF3D00", // Red
            url: "#" 
        },
        { 
            title: "3. Lift Assembly", 
            pages: "Pages 32-49", 
            qc: "Friction & Symmetry check",
            color: "#00C853", 
            url: "#" 
        },
        { 
            title: "4. Intake Mechanism", 
            pages: "Pages 50-65", 
            qc: "Chain tension check",
            color: "#FF3D00", 
            url: "#" 
        },
        { 
            title: "5. Final Integration", 
            pages: "Pages 66-71", 
            qc: "Cable management check",
            color: "#00C853", 
            url: "#" 
        },
        // EXAMPLE: Uncomment the object below to instantly add a 6th stage!
        /*
        { 
            title: "6. Competition Prep", 
            pages: "Post-Build", 
            qc: "Battery & Firmware",
            color: "#2962FF", 
            url: "#" 
        } 
        */
    ];

    // ==========================================
    // 2. THE ENGINE (Drawing Logic)
    // ==========================================
    const canvas = document.getElementById('roadmapCanvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    
    // Store calculated node positions here for click detection
    let nodePositions = []; 

    function drawRoadmap() {
        const width = canvas.width;
        const height = canvas.height;
        const padX = 80;  // Padding sides
        const amplitude = 60; // How "wavy" the road is
        const centerY = height / 2;
        
        ctx.clearRect(0, 0, width, height);

        // -- A. Draw the Road (The Wavy Line) --
        ctx.beginPath();
        ctx.lineWidth = 40;
        ctx.strokeStyle = '#555'; // Road color
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // We draw points along a sine wave
        for (let x = padX; x <= width - padX; x++) {
            // Normalize x to 0-1 range for math
            const progress = (x - padX) / (width - padX * 2);
            // Math.sin creates the wave. (progress * Math.PI * 3) creates 1.5 cycles
            const y = centerY + Math.sin(progress * Math.PI * 3) * amplitude;
            
            if (x === padX) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();

        // -- B. Draw Center Strip (Dashed Line) --
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.setLineDash([10, 10]);
        for (let x = padX; x <= width - padX; x++) {
            const progress = (x - padX) / (width - padX * 2);
            const y = centerY + Math.sin(progress * Math.PI * 3) * amplitude;
            if (x === padX) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // -- C. Draw Checkpoints --
        nodePositions = []; // Reset stored positions

        const totalPoints = checkpoints.length;
        
        checkpoints.forEach((point, index) => {
            // Calculate X/Y for this specific node
            // We distribute them evenly across the width
            const progress = index / (totalPoints - 1);
            
            // Map progress (0 to 1) to the canvas width (padX to width-padX)
            const x = padX + progress * (width - padX * 2);
            const y = centerY + Math.sin(progress * Math.PI * 3) * amplitude;

            // Save for hit testing
            nodePositions.push({ x, y, data: point, radius: 25 });

            // Draw Shadow
            ctx.beginPath();
            ctx.arc(x, y + 5, 25, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();

            // Draw Circle Background
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.fillStyle = point.color;
            ctx.fill();

            // Draw Circle Border
            ctx.lineWidth = 4;
            ctx.strokeStyle = 'white';
            ctx.stroke();

            // Draw Number
            ctx.fillStyle = 'white';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(index + 1, x, y);
            
            // Draw Title Label below node
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(point.title, x, y + 45);
        });
    }

    // ==========================================
    // 3. INTERACTION (Events)
    // ==========================================
    
    // Mouse Move: Check for hovering over nodes
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        let hit = false;

        nodePositions.forEach(node => {
            // Calculate distance between mouse and node center
            const dist = Math.sqrt((mouseX - node.x) ** 2 + (mouseY - node.y) ** 2);

            if (dist < node.radius) {
                hit = true;
                
                // Show Tooltip
                tooltip.style.display = 'block';
                tooltip.style.left = (node.x + 20) + 'px'; // Offset slightly
                tooltip.style.top = (node.y - 80) + 'px';
                tooltip.style.borderColor = node.data.color;
                
                // Inject HTML Content
                tooltip.innerHTML = `
                    <h3>${node.data.title}</h3>
                    <p class="meta">${node.data.pages}</p>
                    <p>QC: ${node.data.qc}</p>
                    <p class="hint">Click to open resource &rarr;</p>
                `;
                
                // Change cursor to pointer
                canvas.style.cursor = 'pointer';
            }
        });

        if (!hit) {
            tooltip.style.display = 'none';
            canvas.style.cursor = 'default';
        }
    });

    // Mouse Click: Open URL
    canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        nodePositions.forEach(node => {
            const dist = Math.sqrt((mouseX - node.x) ** 2 + (mouseY - node.y) ** 2);
            if (dist < node.radius) {
                if(node.data.url && node.data.url !== "#") {
                    window.open(node.data.url, '_blank');
                } else {
                    alert("No link configured for this stage yet!");
                }
            }
        });
    });

    // Initial Draw
    drawRoadmap();

</script>
</body>
</html>